# Interpreter in Go

## ステップ

- ソースコード --(Lexer)--> トークン列 --(Parser)--> AST(抽象構文器) --(Evaluator)--> バイトコード
- LexerとParserの分担は絶対ではない。

1. 字句解析器(Lexer)

- ソースを意味のある最小単位の文字列(=トークン)に分解する = トークナイズ

2. 構文解析器(Parser)

- トークンを構造化データとして整理する
- データ構造の多くは、構文木や AST(抽象構文木)が多い

3. 評価器(Evaluator)

## 字句解析器(Lexer)

- トークンの定義
  - 識別子(x,y,1,5,10)
  - 演算子(+-\*/=<>)
  - デリミタ(){}[],:;
  - キーワード(function, let, if, true, false..etc)
  - 終端記号(EOF)
- 実装
  - lex/flex
  - OOLEX

## 構文解析器(Parser)

- トークン列を何らかのデータ構造に変換する
- データ構造の多くは、以下が多い
  - 構文木(Syntax Tree)
  - 抽象構文木(Abstract Syntax Tree)
- データをシリアライズされたデータに落とし込むのと同じイメージ(JSON, YAML, TOML, INI..etc)
- パーサジェネレータ(bison, yacc, ANTLR)は今回使わない。
- コンピュータサイエンスで最もよく研究されている分野
- 以下 2 つの手法がある
  - トップダウン構文解析
    - 再帰下降構文解析
      - Pratt 構文解析 <==こちらを今回利用
    - アーリー法
    - 予測的構文解析
  - ボトムアップ構文解析

## ポイント

- テストの入力には字句解析器のモックやスタブを用意せず、ソースコードそのものを入力として与える。何のテストなのか理解しやすいため。
